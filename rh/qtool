#!/bin/bash

prog_name=$0
my_email="peterx@redhat.com"
my_fullname="Peter Xu"
my_sob_line="Signed-off-by: ${my_fullname} <${my_email}>"
debug=false

# we count the user of the fake editor, when reach zero, we unset
# the fake editor. To gain ref, use git_set_fake_editor(), to
# release ref, use git_unset_fake_editor()
fake_editor_refcount=0

usage ()
{
    cat <<EOF
usage: $prog_name <cmd>

supportted cmds:

auto-apply:            apply patche list automatically
auto-bisect:           automatic bisection of bad codes
build-initrd:          build initrd.img from directory
create-initrd-root:    create basic initramfs under directory specified
fake-editor:           this is a fake editor, it pauses, wait for a
                       SIGUSR1 and then quit with errno=0
git-commit-set-cc:     auto-generate CC list for commit
                       (this will remove all existing CC list!)
git-commit-get-cc:     list all CC list for specific commit
git-fix-commit:        fix specific git commit (rebase)
git-self-review:       do self review of git commits
git-compile-check:     check compile for commit range
git-tag-cleanup:       cleanup useless git tags created by git-publish
init-dev:              init dev environment for host
install-dev:           install packages for dev
kernel-backtrace:      dump backtrace for kernel function
kernel-boot:           choose which version of kernel to boot in host
kernel-grep-function:  find kernel function with key
kernel-install:        install the kernel (to specific VM)
kernel-quit:           stop the running kernel...
kernel-run:            run specific kernel using QEMU
kernel-cleanup:        remove kernel of specific version
prepare-send:          prepare one script to send patches
pci:                   some PCI related operations
qemu-build:            build QEMU repository.
send-patch:            send patches using git-send-email
ssh-host:              SSH to host, with line buffering
status-report:         generate status report
vpnc-dial-in:          dial in VPN

EOF
    exit 1
}

debug ()
{
    if $debug; then
        echo -n "[DEBUG_QTOOL] " >&2
        echo $@ >&2
    fi
}

err ()
{
    echo "ERROR: $@"
    exit 1
}

COLOR_RED='\033[0;31m'
COLOR_GREEN='\033[0;32m'
COLOR_YELLOW='\033[0;33m'
COLOR_NC='\033[0m' # No Color

echo_color()
{
    local color="$1"
    shift 1
    local prefix=""

    case $color in
        red|bad) prefix="$COLOR_RED" ;;
        green|good) prefix="$COLOR_GREEN" ;;
        yellow|warn) prefix="$COLOR_YELLOW" ;;
        *) echo "PANIC"; exit 1 ;;
    esac

    echo -en "$prefix"
    echo -n $@
    echo -e "$COLOR_NC"
}

read_yes()
{
    local answer
    read answer
    case $answer in
        yes|y) return 0 ;;
        *) return 1;;
    esac
}

is_number()
{
    [[ "$1" =~ ^[0-9]+$ ]]
}

is_quit()
{
    [[ "$1" == "quit" || "$1" == "q" || \
           "$1" == "exit" || "$1" == "" ]]
}

wait_until_file_exists ()
{
    while [[ ! -f "$1" ]]; do
        sleep 0.1
    done
}

wait_pid_quit ()
{
    while kill -0 $1 &> /dev/null; do
        sleep 0.1
    done
}

do_qemu_build ()
{
    local current=$(pwd)
    local pdir=$(dirname $current)
    local top=$(basename $current)
    local args="$1"
    local target_list="x86_64-softmmu,aarch64-softmmu,ppc64-softmmu,x86_64-linux-user"

    if [[ "$args" == "--help" ]]; then
        cat <<EOF
usage: $prog_name qemu-build [arch_list]

Configure/Build QEMU under $QEMU_REPO/bin/ directory.
EOF
        return 1
    fi

    if [[ -n "$args" ]]; then
        if [[ "$args" == "all" ]]; then
            target_list=""
        else
            target_list="$args"
        fi
    fi

    if [[ -n "$target_list" ]]; then
        target_list="--target-list=$target_list"
    fi

    if [[ ! "$top" == bin* ]]; then
        echo "please run this under QEMU_ROOT/bin*"
        return 1
    fi

    ../configure $target_list \
                 --enable-debug --enable-spice \
                 --enable-usb-redir

    if [[ $? != 0 ]]; then
        echo "configure failed, stop here"
        return 1
    fi

    make -j8
    if [[ $? != 0 ]]; then
        echo "build failed... stop here"
        return 1
    fi
}

do_init_dev ()
{
    local files=".inputrc .bashrc .gitconfig .vimrc"
    local host="$1"

    if [[ -z "$host" ]]; then
        cat <<EOF
usage: $prog_name init-dev <host>

Init dev environment for <host>. <host> is required.
EOF
        return 1
    fi

    echo "copy SSH public key..."
    ssh-copy-id $host || err "failed copy SSH public key"

    echo "copy config files..."
    for file in $files; do
        path=/root/$file
        scp $path $host:$path || err "copy file $path failed"
    done
}

initrd_img="initrd.img"

do_build_initrd ()
{
    local dir="$1"
    local err=0
    if [[ -z "$dir" ]]; then
        cat <<EOF
usage: $prog_name build-initrd <dir>

Build $initrd_img file by packing dir.
EOF
        exit 1
    fi

    # check /init script
    if [[ ! -f "$dir/init" ]]; then
        echo "please provide $dir/init file (at least!)"
        return 1
    fi

    local img="$PWD/$initrd_img"
    pushd $dir &> /dev/null
    find . | cpio -H newc -o | gzip > $img
    if [[ $? == 0 ]]; then
        echo "$initrd_img created at $img"
        err=0
    else
        echo "failed to create $initrd_img"
        err=1
    fi
    popd &> /dev/null
    return $err
}

# before run this, we should have the following directories under PWD:
# "kernel": as INSTALL_PATH for kernel make
# "initramfs": rootfs for the system to be booted. to create one,
#              check: http://jootamam.net/howto-initramfs-image.htm
# "modules": as INSTALL_MOD_PATH for kernel make (currently not used)
do_kernel_run()
{
    # specify "-S" to halt QEMU when boot
    extra_params="$@"
    kernel_dir="$PWD/kernel"
    initrd_dir="$PWD/initramfs"
    qemu_bin=$(which qemu-kvm 2>/dev/null)

    if [[ $? != 0 ]]; then
        echo "please install qemu-kvm first"
        return 1
    fi

    if [[ ! -d "$kernel_dir" ]]; then
        echo "cannot find kernel dir $kernel_dir"
        return 1
    fi

    if [[ ! -d "$initrd_dir" ]]; then
        echo "cannot find initramfs dir $initrd_dir"
        return 1
    fi

    # build initrd every time!
    if ! do_build_initrd $initrd_dir; then
        return 1
    fi

    # try to find the kernel
    kernel_file=$(find $kernel_dir -name "vmlinuz*")
    lines=$(echo "$kernel_file" | wc -l)

    if [[ "$lines" != 1 ]]; then
        echo "found more than one kernel under $kernel_dir?"
        return 1
    fi

    $qemu_bin -enable-kvm -m 1024 -kernel $kernel_file \
              -initrd $initrd_img -nographic \
              -append "console=ttyS0" -s $extra_params

    # after this, we should be able to debug the kernel using:
    # $ gdb $VMLINUX_PATH
    # (gdb) set architecture i386:x86-64:intel
    # (gdb) target remote localhost:1234
}

do_kernel_quit ()
{
    pkill -f "$prog_name kernel-run"
}

do_auto_apply()
{
    patches="$@"
    count=0
    if [[ -z "$patches" ]]; then
        echo "usage: auto_apply <patch1> [patch2 [patch3 ...]]"
        echo
        echo "This will do the following:"
        echo "  1. Try apply patch locally (try -p0 then -p1)"
        echo "  2. Commit the patch using git"
        echo
        echo "Will stop when failed to apply a patch"
        echo
        echo "Example: # qtool auto_apply /root/rpmbuild/SOURCES/*.patch"
        return 1
    fi
    for patch in $patches; do
        applied=false
        if [[ $patch != /* ]]; then
            echo "Please provide patch full path for $patch"
            return 1
        fi
        for level in 1 0; do
            patch -t -p$level < $patch
            if [[ $? == 0 ]]; then
                applied=true
                break
            fi
        done
        if ! $applied; then
            echo "patch '$patch' failed to apply, stop here."
            return 1
        fi
        # TODO: when there are new files, I'd better detect it and
        # commit too.
        git commit -a -m "Apply patch $(basename $patch)"
        count=$(( $count + 1 ))
    done
    echo "All $count patches applied successfully."
    echo "Please service yourself to cleanup *.orig."
}

init_script_def='#!/bin/sh

# Based on: http://jootamam.net/howto-initramfs-image.htm

# Create all the symlinks to /bin/busybox
/bin/busybox --install -s /bin

# Mount things needed by this script
mount -t proc proc /proc
mount -t sysfs sysfs /sys

# Disable kernel messages from popping onto the screen
# echo 0 > /proc/sys/kernel/printk

# Create device nodes
mknod /dev/null c 1 3
mknod /dev/tty c 5 0
mdev -s

# Function for parsing command line options with "=" in them
# get_opt("init=/sbin/init") will return "/sbin/init"
get_opt() {
        echo "$@" | cut -d "=" -f 2
}

# Defaults
init="/sbin/init"
root="/dev/vda1"

# Process command line options
for i in $(cat /proc/cmdline); do
        case $i in
                root\=*)
                        root=$(get_opt $i)
                        ;;
                init\=*)
                        init=$(get_opt $i)
                        ;;
        esac
done

# Mount the root device
mount "${root}" /newroot

# Check if $init exists and is executable
if [[ -x "/newroot/${init}" ]] ; then
        # Unmount all other mounts so that the ram used by
        # the initramfs can be cleared after switch_root
        umount /sys /proc

        #Switch to the new root and execute init
        exec switch_root /newroot "${init}"
fi

# This will only be run if the exec above failed
echo "Failed to switch_root, dropping to a shell"
exec sh
'

do_create_initrd_root ()
{
    local dir_name="$1"

    if [[ -z "$dir_name" ]]; then
        cat <<EOF
usage: $prog_name create-initrd-root <dir_name>

This command will create one minimum rootfs layout under <dir_name>
specified.
EOF
        return 1
    fi

    if [[ -e "$dir_name" ]]; then
        echo -n "Path $dir_name exists, "
        echo "please manually remove it before hand"
        return 1
    fi

    local busybox_path=$(which busybox 2>&1)
    if [[ $? != 0 ]]; then
        echo "Failed to find busybox, please install it before hand"
        return 1
    fi

    mkdir $dir_name || err "create dir $dir_name failed"

    cd $dir_name
    local dir_list="bin sbin etc proc sys newroot"
    local name=""

    echo "Creating directories: $dir_list"
    for name in $dir_list; do
        mkdir $name
    done

    echo "Creating mdev.conf"
    touch etc/mdev.conf

    echo "Installing busybox"
    cp $busybox_path bin/busybox
    chmod a+x bin/busybox
    ln -s busybox bin/sh

    echo "Creating /init"
    echo "$init_script_def" > init
    chmod a+x init

    echo "Initramfs root created under $dir_name successfully."
    return 0
}

__host_ssh_reachable ()
{
    ssh $1 ls &> /dev/null
}

do_kernel_install ()
{
    # set this if we want to copy the kernels to VM
    local vm="$1"
    shift 1
    local params="$@"
    local set_default=false
    local kernel_only=false
    local output_dir="qtool_output"

    if [[ -z "$vm" ]]; then
        cat <<EOF
usage: $prog_name kernel-install <vm> [option [option...]]

This will install kernel and modules into <vm>.

<vm>: should be the name of the VM, with SSH pub key copied before
      hand.

Supported options:

set_default: set this parameter non-empty to set new kernel as
             default one
kernel_only: only install compressed kernel to /boot

EOF
        return 1
    fi

    if ! __host_ssh_reachable $vm; then
        echo "VM $vm not reachable by SSH"
        return 1
    fi

    local param=""
    for param in $params; do
        case $param in
            set_default) set_default=true ;;
            kernel_only) kernel_only=true ;;
            *) echo "unknown option: $param"; return 1 ;;
        esac
    done

    rm -rf $output_dir
    mkdir $output_dir

    ##############################
    # kernel
    ##############################

    echo "Preparing kernel..."
    make install INSTALL_PATH=$output_dir

    # get kernel version
    local kernel_version=""
    kernel_version=$(ls $output_dir/vmlinuz-*)
    if [[ $? != 0 ]]; then
        echo "failed to find file $output_dir/vmlinuz-*"
        return 1
    fi
    kernel_version=${kernel_version##*vmlinuz-}
    echo "Kernel version to install:  '$kernel_version'"
    echo "Remote machine hostname:    '$vm'"

    echo "removing old kernel (if exists)"
    ssh $vm rm -f /boot/*${kernel_version}

    echo "installing kernel"
    scp $output_dir/*-${kernel_version} $vm:/boot/ > /dev/null

    if $kernel_only; then
        echo "doing kernel-only install, done."
        return 0
    fi

    ##############################
    # modules
    ##############################

    echo "Preparing modules..."
    make modules_install INSTALL_MOD_PATH=$output_dir

    # cleanup "build" and "source" in case they are soft links
    local module_dir="$output_dir/lib/modules/${kernel_version}"
    if [[ ! -d $module_dir ]]; then
        echo "failed to find module directory: $module_dir"
        return 1
    fi
    for file in build source; do
        rm -f $module_dir/$file
    done

    echo "removing old modules (if exists)"
    # the initramfs
    ssh $vm rm -f /boot/*${kernel_version}.img
    ssh $vm rm -rf /lib/modules/${kernel_version}

    echo "installing modules"
    scp -r $module_dir $vm:/lib/modules > /dev/null

    echo "generating initramfs"
    ssh $vm dracut -H --kver $kernel_version

    echo "updating grub2"
    ssh $vm grub2-mkconfig -o /boot/grub2/grub.cfg

    if $set_default; then
        echo "setting default boot kernel to $kernel_version"
        qtool kernel-boot $vm $kernel_version
    fi

    echo "all done"
}

do_kernel_boot_select ()
{
    local vm="$1"
    local version="$2"

    if [[ -z "$vm" || -z "$version" ]]; then
        cat <<EOF
usage: $prog_name kernel-boot <host> <kernel_version>

Modify grub configuration to boot into <kernel_version> next time. 
EOF
        return 1
    fi

    if ! __host_ssh_reachable $vm; then
        echo "host $vm not reachable"
        return 1
    fi

    local index=""
    index=$(ssh $vm grub2-mkconfig -o /boot/grub2/grub.cfg 2>&1 | \
                sed -n '/linux image/p' | sed -n /${version}\$/=)
    if [[ -z "$index" ]]; then
        echo "failed to find kernel version $version on host $vm"
        return 1
    fi
    # move start offset to 0 (not 1)
    index=$(( $index - 1 ))
    ssh $vm sed -i "s\/^GRUB_DEFAULT=.*\$\/GRUB_DEFAULT=${index}\/" \
        /etc/default/grub
    ssh $vm grub2-mkconfig -o /boot/grub2/grub.cfg &> /dev/null
}

qtool_def_bisect_script=".qtool.bisect"

__auto_bisect_help()
{
    cat <<EOF
usage:

# $prog_name auto-bisect generate

  Generate the default bisect file $qtool_def_bisect_script

# $prog_name auto-bisect run

  Run the bisect script $qtool_def_bisect_script

The script file should contain the following functions:

qtool_bisect_prepare:    build codes into binaries, and install
qtool_bisect_run:        run scripts to trigger the bug, return 0
                         means test pass, ~0 means test fail

The logic of bisection will be:

1. qtool_bisect_prepare
2. qtool_bisect_run --> result
3. update result to git
4. finished ? (END) : (goto 1.)
EOF
    return 1
}

__auto_bisect_generate_script ()
{
    if [[ -e $1 ]]; then
        echo "found existing script at $1, please remove before new"
        return 1
    fi
    cat > $1 <<EOF
#!/bin/bash

qtool_bisect_prepare ()
{
    echo "Preparing for run..."

    # do everything needed for the new run, should include but not
    # limited to: build, install, config, etc.

    # return 0 on success, 1 on error
    return 0
}

qtool_bisect_run ()
{
    echo "Running bisect script..."

    # run script to see whether test pass

    # return 0 on test pass, 1 on fail, 2 on error
    return 0
}
EOF
}

__auto_bisect_run()
{
    local round=1
    local result=0
    source $1

    while true; do
        echo "###############################"
        echo "# Round $round of prepare"
        echo "###############################"
        date
        if ! qtool_bisect_prepare; then
            echo "failed prepare bisect"
            return 1
        fi

        echo "###############################"
        echo "# Round $round of run"
        echo "###############################"
        date
        qtool_bisect_run
        result=$?

        case $result in
            1) git_answer=bad ;;
            0) git_answer=good ;;
            *)
                echo "error happened during running bisect script"
                return 1
                ;;
        esac

        echo "#######################################"
        echo "# Round $round of git update: $git_answer"
        echo "#######################################"
        git bisect $git_answer | grep -q "first bad"
        if [[ $? == 0 ]]; then
            # we got the bad one
            echo "found bad commit, stop here"
            git bisect log | tail -1
            break
        fi

        round=$(( $round + 1 ))
    done

    return 0
}

do_auto_bisect ()
{
    local cmd="$1"
    local script="$qtool_def_bisect_script"

    if [[ -z "$cmd" ]]; then
        __auto_bisect_help
        return 1
    fi

    case $cmd in
        generate) __auto_bisect_generate_script $script ;;
        run) __auto_bisect_run $script ;;
        *) __auto_bisect_help ;;
    esac

    return $?
}

# Tries to translate a nickname into email address
nick_to_email()
{
    local nick="$1"
    local alias_book="/root/.mutt/aliases"
    local info=""

    info=$(grep -w $nick $alias_book 2>/dev/null | head -1)
    if [[ -z "$info" ]]; then
        return
    fi
    info=${info##*<}
    info=${info%%>*}
    echo $info
}

do_send_patch ()
{
    local maillist="$1"
    # always CC myself.
    local cclist="$2,$my_email"
    shift 2
    local patchlist="$@"
    local tolist=""
    local param=""

    if [[ -z "$patchlist" ]]; then
        cat <<EOF
usage: $prog_name send-patch <mailing lists> <cc list> <patch1> ...

<mailing list> and <cc list> items should be splitted by comma
(",").

Send patch list to specific mailing list, with all the people CCed
in the CC list.
EOF
        return 1
    fi

    maillist="${maillist//,/ }"
    cclist="${cclist//,/ }"

    local mlist=""
    for mlist in ${maillist}; do
        case $mlist in
            qemu*) tolist="$tolist qemu-devel@nongnu.org" ;;
            rhvirt*) tolist="$tolist rhvirt-patches@redhat.com" ;;
            libvir*) tolist="$tolist libvir-list@redhat.com" ;;
            kvm) tolist="$tolist kvm@vger.kernel.org" ;;
            lkml|kernel)
                tolist="$tolist linux-kernel@vger.kernel.org" ;;
            # this is specific email address
            *@*) tolist="$tolist $mlist" ;;
            *) echo "Unknown mailing list: $mlist"; return 1 ;;
        esac
    done

    local item=""

    if [[ -z "$tolist" ]]; then
        echo "To: cannot be empty"
        return 1
    fi

    echo "Sending To:"
    echo
    for item in $tolist; do
        echo "  $item"
        param="$param --to=$item"
    done
    echo

    echo "CC To:"
    echo
    if [[ -n "$cclist" ]]; then
        for item in $cclist; do
            if [[ "$item" != "*@*" ]]; then
                # assume this is a nick
                local email=$(nick_to_email $item)
                if [[ -n "$email" ]]; then
                    item="$email"
                fi
            fi
            echo "  $item"
            param="$param --cc=$item"
        done
    else
        echo "  (nobody)"
    fi
    echo

    echo "Patches to send:"
    echo
    for item in $patchlist; do
        echo "  $item"
        param="$param $item"
    done
    echo

    echo -n "Ready to send? (y/n) "
    read y
    if [[ $y != y ]]; then
        echo "Aborted."
        return 0
    fi

    echo "Sending..."
    git send-email --suppress-cc=all $param
    echo "Done."
}

do_ssh_host()
{
    local host="$1"
    if [[ -z "$host" ]]; then
        cat <<EOF
usage: $prog_name <host>

SSH to <host> with line buffering. This might be easy to use when
ping has a very big latency from local to <host>.
EOF
        return 1
    fi

    local line=""
    cat | ssh $host
}

# this must be done before everything, since we are calling err() to
# quit when check failed
git_root_check()
{
    if [[ ! -d ".git" ]]; then
        err "Please run command under root dir of git repo"
    fi
}

git_no_modify_check ()
{
    if git status | grep -qw modified; then
        err "Detected modified files, please clean first"
    fi
}

git_config_core_editor_check ()
{
    local editor=""
    if [[ $fake_editor_refcount != 0 ]]; then
        # we are in, no need to check
        return
    fi
    editor=$(git config --local core.editor 2>/dev/null)
    if [[ -n "$editor" ]]; then
        err "Please make sure local core.editor not set"
    fi
}

git_fake_editor_check()
{
    if pgrep -fa fake-editor &> /dev/null; then
        err "Please stop all fake-editor"
    fi
}

git_commit_check()
{
    local commit="$1"
    if [[ -z "$commit" ]]; then
        err "commit empty"
    fi
    if ! git show -s --oneline $commit &> /dev/null; then
        err "commit $commit does not exist"
    fi
}

git_rebase_pre_check_all()
{
    git_root_check
    git_no_modify_check
    git_config_core_editor_check
    git_fake_editor_check
}

git_using_fake_editor()
{
    local editor=$(git config --local core.editor 2>/dev/null)
    return [[ "$editor" == *fake-editor* ]]
}

git_set_fake_editor()
{
    fake_editor_refcount=$(( $fake_editor_refcount + 1 ))
    debug "fake editor cnt: $fake_editor_refcount"

    if [[ $fake_editor_refcount == 1 ]]; then
        debug "setting fake editor"
        git config --local core.editor "$prog_name fake-editor"
    fi
}

git_unset_fake_editor()
{
    fake_editor_refcount=$(( $fake_editor_refcount - 1 ))
    debug "fake editor cnt: $fake_editor_refcount"

    if [[ $fake_editor_refcount == 0 ]]; then
        debug "unsetting fake editor"
        git config --local --unset core.editor
    fi
}

# this is the file to store which file we are editing on. Current we
# still do not support concurrent operations. However, is that
# matter? I suppose in most cases not, since we are simulating a
# human being from his typing, man!
fake_editing_file=".fake_editor.current_path"

# To play the trick, we trap USR1 signal. When script is ready to do
# anything, we can just signal this process with USR1 to quit
# gracefully.
do_fake_editor ()
{
    # save current editing file path
    echo "$1" > $fake_editing_file
    trap "keep=false" USR1
    while $keep; do
        # some other people (possibly scripts :) is editing this
        # file.. let's wait a SIGUSR1 from thay guy!
        sleep 0.05
    done
    return 0
}

fake_editor_close()
{
    # notify fake editor to quit
    pkill -f -USR1 "$prog_name fake-editor"
}

# get which file to read, also, we will make sure the file is there
# when return
fake_editor_get_path()
{
    local file=""
    # first, make sure our fake editor starts working, and it will
    # drop the path of file-to-edit here...
    wait_until_file_exists $fake_editing_file

    file=$(cat $fake_editing_file)
    debug "fake editor currently editing file: $file"
    # secondly, we need to make sure the file to be edited is
    # existing too (for git operations, git will help create them
    # with some init state, we need to wait for its ready).
    wait_until_file_exists $file

    # remove it after we used it
    rm -f $fake_editing_file

    # tell caller
    echo $file
}

# This function will emulate the rebase operation of the user. This
# is used for command "fix-commit" and "git-self-review".
#
# Parameters:
#
# 1. commit number to rebase on
# 2. a hook function to run to simulate the rebase editing
#    procedure. The function should take one argument, which is the
#    file of GIT_REBASE_TODO, which is possibly located in .git/
#    directory. In the hook function, we can modify the todo file as
#    our wish.
git_rebase_with_hook ()
{
    local commit="$1"
    local hook_func="$2"

    if [[ -z "$commit" || -z "$hook_func" ]]; then
        err "need commit and hook func"
    fi

    local git_rebase_todo=""
    local rebase_pid=""

    git_rebase_pre_check_all
    git_set_fake_editor

    # TODO: here we'd better capture PID of the fake editor
    git rebase -i "${commit}~" &> /dev/null &
    rebase_pid=$!

    git_rebase_todo=$(fake_editor_get_path)

    eval $hook_func $git_rebase_todo

    fake_editor_close
    # we need to wait for "git rebase" finish its work, so that we
    # can have good tree status to move on
    wait_pid_quit $rebase_pid

    git_unset_fake_editor
}

git_commit_fix_hook ()
{
    # edit current commit only
    sed -i '1 s/pick/edit/' $1
}

do_git_commit_fix ()
{
    local commit="$1"

    if [[ -z "$commit" ]]; then
        cat <<EOF
usage: $prog_name <commit>

Fix specific commit using rebase. After fix, please use:

# git rebase --continue

To continue.
EOF
        return 1
    fi

    git_rebase_with_hook $commit git_commit_fix_hook

    echo "We are on commit:"
    git show -s --oneline
    echo "Please use 'git rebase --continue' after fix done."
}

git_self_review_hook ()
{
    # edit all commits
    sed -i 's/^pick/edit/' $1
}


do_git_self_review ()
{
    local commit="$1"

    if [[ -z "$commit" ]]; then
        cat <<EOF
usage: $prog_name <commit>

Do self review of commits from <commit>. This is to rebase to that
commit, and edit one by one. This is very useful when we want to do
self-review of written patches, and modify in-place when we need.
EOF
        return 1
    fi

    git_rebase_with_hook $commit git_self_review_hook

    echo "We are on commit:"
    git show -s --oneline
    echo "Please use 'git rebase --continue' to move on the review."
}

# this could be an alias of real get_maintainer script. We need to
# do the aliasing manually. The script should be able to work just
# as QEMU/Linux scripts/get_maintainer.pl.
get_maintainer_script="./.get_maintainer"

get_maintainer_script_check()
{
    if [[ ! -e "$get_maintainer_script" ]]; then
        err "failed to find script: $get_maintainer_script"
    fi
}

# split using "|"
cc_filter_list="qemu-devel@nongnu.org"

do_git_commit_get_cc ()
{
    local commit="$1"

    if [[ -z "$commit" ]]; then
        cat <<EOF
usage: $prog_name git-commit-get-cc <commit|A..B>

Get CC list for specific commit, or commit range.

List of emails to be filtered out:

$cc_filter_list
EOF
        return 1
    fi

    git_root_check
    get_maintainer_script_check

    if [[ "$commit" == *..* ]]; then
        # this is a range
        :
    else
        # this is a commit
        git_commit_check $commit
        commit="${commit}~..${commit}"
    fi

    git diff ${commit} | $get_maintainer_script | \
        sed 's/ (.*//; s/^/CC: /' | grep -vE "$cc_filter_list"
}

do_git_commit_set_cc_one ()
{
    local commit="$1"

    if [[ -z "$commit" ]]; then
        cat <<EOF
usage: $prog_name git-commit-set-cc <commit>

Will automatically add "CC:" lines for specific commit. This is
EXTREMELY DANGEROUS, please make sure you know what this is doing
before using it. To do this, rebase is required.
EOF
        return 1
    fi

    git_commit_check $commit
    git_set_fake_editor

    echo "Trying to auto-generate CC: lines for commit $commit."

    # first, switch to that commit using rebase
    do_git_commit_fix $commit > /dev/null

    # still using fake-editor, remember? ;)
    git commit --amend &> /dev/null &

    local commit_path=$(fake_editor_get_path)
    local tmp_path="./.temp_commit_msg"
    local answer=""

    echo "Original commit msg for $commit:"
    echo "================================"
    cat $commit_path | grep -v "^#" | tee $tmp_path
    echo "================================"

    # first of all, remove existing CCs
    sed -i '/^CC: /d' $tmp_path

    # then, add all maintainer CCs
    local line=""
    do_git_commit_get_cc HEAD | while read line; do
        sed -i "/${my_sob_line}/i ${line}" $tmp_path
    done

    echo "New commit msg for $commit:"
    echo "================================"
    cat $tmp_path
    echo "================================"

    echo -n "Good to go? (y/n) "
    read answer
    if [[ "$answer" == y ]]; then
        echo "Committing changes"
        cp $tmp_path $commit_path
    else
        echo "Giving up changes"
    fi
    rm -f $tmp_path

    fake_editor_close

    git rb --continue &> /dev/null

    # release fake editor refcount
    git_unset_fake_editor
}

do_git_commit_set_cc()
{
    local commit="$1"

    if [[ -z "$commit" ]]; then
        cat <<EOF
usage: $prog_name git-commit-set-cc <commit|-N|A..B>

<commit> can be one specific commit number, or something like "-3"
or "A..B" to do automatic CC appending for all the commits in the
range.
EOF
        return 1
    fi

    local line=""
    local commits=""

    commits=$(git show -s --oneline $commit | awk '{print $1}')
    for commit in $commits; do
        do_git_commit_set_cc_one $commit
    done
}

do_prepare_send ()
{
    local script=".send.sh"
    if [[ -f $script ]]; then
        echo "Script $script already exist!"
        return 1
    fi
    cat > $script <<EOF
#!/bin/bash
to_list=
cc_list=
patches=
qtool send-patch \$to_list \$cc_list \$patches
EOF
    chmod a+x $script
    echo "Script generated at $script."
}

vpnc_trigger_file="/root/.private/.vpnc-trigger"

do_vpnc_dial_in()
{
    if [[ -f $vpnc_trigger_file ]]; then
        echo_color green "Detected VPNC trigger, using it"
        bash $vpnc_trigger_file
    else
        local vpnc_cmd="vpnc "

        pgrep -f "vpnc" | while read pid; do
            echo "Detected existing vpnc process, killing..."
            kill $pid
            sleep 1
        done
        $vpnc_cmd
    fi

    if [[ $? != 0 ]]; then
        echo "VPN connection failed."
        return 1
    fi

    sleep 1
    echo "Re-starting offlineimap service..."
    pkill -9 -f /usr/bin/offlineimap

    return 0
}

__trace_root="/sys/kernel/debug/tracing"
__set_ftrace_filter="$__trace_root/set_ftrace_filter"
__available_filter_functions="$__trace_root/available_filter_functions"
__trace_pipe="$__trace_root/trace_pipe"

ftrace_set_on ()
{
    echo $1 > $__trace_root/tracing_on
}

ftrace_log_clear ()
{
    echo > $__trace_root/trace
}

ftrace_current_set()
{
    echo $1 > $__trace_root/current_tracer
}

ftrace_function_filter_clear()
{
    local line=""

    # remove all function tracepoints
    echo > $__set_ftrace_filter

    # clear all other tracepoints
    cat $__set_ftrace_filter | grep 'stacktrace:unlimited' | while read line; do
        echo '!'"${line%%:unlimited}" > $__set_ftrace_filter
    done
}

ftrace_reset()
{
    ftrace_set_on 0
    ftrace_log_clear
    ftrace_current_set nop
    ftrace_function_filter_clear
}

ftrace_dump_pipe()
{
    trap 'echo -e "\rSTOPPING TRACE DUMP"' SIGINT SIGTERM
    echo "STARTING TRACE DUMP"
    cat $__trace_pipe
}

ftrace_function_exists()
{
    grep -qw $1 $__available_filter_functions
}

ftrace_do_backtrace()
{
    local func=""
    for func in $@; do
        if ! ftrace_function_exists $func; then
            echo "Function $func does not exist"'!'
            return 1
        fi
        # it did exist, hook with backtrace
        echo "Adding stacktrace hook for $func"
        echo "${func}:stacktrace" >> $__set_ftrace_filter
    done
}

do_backtrace ()
{
    local func_list="$@"

    if [[ -z "$func_list" ]]; then
        cat <<EOF
usage: $prog_name backtrace <func1> [func2 [func3 ...]]

Trace kernel function and dump backtrace for it.

CAUTION: this is based on ftrace and cannot be used in parallel with
other ftrace consumers like trace-cmd, etc.
EOF
        return 1
    fi

    ftrace_reset
    if ftrace_do_backtrace $func_list; then
        ftrace_set_on 1
        ftrace_dump_pipe
    fi
    # do clean up no matter what happened
    ftrace_reset
}

do_kernel_grep_function()
{
    grep -E --color $1 $__available_filter_functions
}

git_rev_list ()
{
    git rev-list --reverse ${1}
}

default_compile_command="make -j8"
default_compile_log="qtool-compile.log"

do_git_compile_check()
{
    local commit_start="$1"
    shift 1
    local cur_branch=""
    local count=""
    local max=""
    local commit_list=""

    if [[ -z "$commit_start" ]]; then
        cat <<EOF
usage: $prog_name git-compile-check <commit> [commands...]

Do compile check for each commit in range <commit>..HEAD

The compile check is done using the following:

1. check out specific commit (from old to new) in order
2. run the command provided (default: "$default_compile_command")
3. check return code for command...
  3.1. command return zero...
    3.1.1. if current commit is HEAD, goto 4.
    3.2.2. if current commit is not HEAD, goto 1.
  3.2. command return non-zero, check fail
4. check success

Last time compilation log will be in: $default_compile_log
EOF
        return 1
    fi

    if [[ -z "$@" ]]; then
        compile_cmd="$default_compile_command"
    else
        compile_cmd="$@"
    fi

    cur_branch=$(git symbolic-ref --short HEAD)
    if [[ $? != 0 || -z "$cur_branch" ]]; then
        echo "Please make sure HEAD is at the branch to test"
        return 1
    fi

    commit_list=$(git_rev_list $commit_start..HEAD)

    count=1
    max=$(echo "$commit_list" | wc -l)
    echo -n "Start compile check for range "
    echo -n "$commit_start..$cur_branch ($max commits)? "
    if ! read_yes; then
        echo "Cancelling compilation check"
        return 1
    fi
    for commit in $commit_list; do
        local info=$(git log --oneline $commit -1 | cut -c-60)
        echo_color yellow "[${count}/${max}] check $info"
        git checkout $commit &> /dev/null
        if [[ $? != 0 ]]; then
            echo_color red "Failed to commit $commit."
            git checkout $cur_branch
            return 1
        fi
        $compile_cmd &> $default_compile_log
        if [[ $? == 0 ]]; then
            echo_color green "Commit $commit check passed."
        else
            echo_color red "Commit $commit check failed."
            git checkout $cur_branch
            return 1
        fi
        count=$(( $count + 1 ))
    done

    echo_color green "Compilation check successful"
    git checkout $cur_branch
}

get_dnf()
{
    if which dnf &> /dev/null; then
        echo dnf
    elif which yum &> /dev/null; then
        echo yum
    else
        echo "Failed to find yum or dnf" >2
        exit 1
    fi
}

do_install_dev ()
{
    local dnf=$(get_dnf)
    local pkgs="gcc automake autoconf git vim wget telnet zlib zlib-devel"
    pkgs="$pkgs glib2 glib2-devel pixman pixman-devel spice-server"
    pkgs="$pkgs spice-server-devel usbredir-devel libguestfs*"

    echo "Going to install following packages: "
    echo
    echo "$pkgs"
    echo
    echo -n "Continue? (y/n)"
    if ! read_yes; then
        return 0
    fi

    $dnf install -y $pkgs
}

kernel_get_versions()
{
    ls /boot/vmlinuz-* | grep -vE "\.fc|rescue" | sed 's/.*vmlinuz-//'
}

kernel_get_files()
{
    local list="/boot/initramfs-KERNEL.img /boot/vmlinuz-KERNEL"
    list="$list /boot/System.map-KERNEL /lib/modules/KERNEL"
    echo ${list//KERNEL/$1}
}

kernel_delete_one()
{
    local files=$(kernel_get_files $1)
    local file

    echo_color yellow "Will remove following files:"
    for file in $files; do
        echo "  $file"
    done
    echo -n "Continue (y/n)? "
    if ! read_yes; then
        echo "Aborting."
        exit 0
    fi

    for file in $files; do
        rm -rf $file
    done
}

do_kernel_cleanup()
{
    local kernel
    local kernel_list
    local count
    local answer

    while :; do
        local kernels=$(kernel_get_versions)

        if [[ -z "$kernels" ]]; then
            echo "No custom kernel exists, will quit."
            return
        fi

        count=0
        echo_color yellow "Existing kernels:"
        for kernel in $kernels; do
            kernel_list[count]=$kernel
            echo "  ($count) $kernel"
            count=$(( $count + 1 ))
        done
        echo -n "Which one to remove (enter to quit): "
        read answer
        if is_quit $answer; then
            return 0
        fi
        if ! is_number $answer; then
            echo_color red "Illegal input '$answer'"
            continue
        fi
        if [[ "$answer" -ge $count ]]; then
            echo_color red "Please input in range (0-$(( $count - 1 )))"
            continue
        fi
        kernel=${kernel_list[$answer]}
        if ! kernel_delete_one $kernel; then
            echo_color red "Failed to delete kernel $kernel"
            return 1
        else
            if ! grub2-mkconfig -o /boot/grub2/grub.cfg &> /dev/null; then
                echo "Failed update grub"
                return 1
            fi
            echo_color green "Removed kernel $kernel successfully"
        fi
    done
}

do_git_tag_cleanup()
{
    local cur_branches=""
    local tags=""

    cur_branches=$(git branch | sed 's/^..//g')
    if [[ $? != 0 ]]; then
        echo "May not under a git directory. Quitting."
        return 0
    fi

    cur_branches=$(echo $cur_branches | sed 's/ /|/g')
    tags=$(git tag | grep "\-v[0-9]" | grep -vE "$cur_branches")

    if [[ -z "$tags" ]]; then
        echo "No useless tags found. Quitting."
        return 0
    fi

    echo_color yellow "Found useless tags:"
    echo "$tags" | sed 's/^/  /'
    echo_color yellow "Are you sure you want to remove all above tags? "
    echo -n "Answer (y|n): "
    if read_yes; then
        for tag in $tags; do
            git tag -d $tag
        done
        echo_color green "Tags removed."
    else
        echo_color green "Quitted."
    fi
}

go_python ()
{
    pybin="$(dirname $(realpath $prog_name))/pyqtool"
    $pybin $@
}

cmd=$1
shift 1

case $cmd in
    qemu-build) do_qemu_build $@ ;;
    init-dev) do_init_dev $1 ;;
    install-dev) do_install_dev $@ ;;
    create-initrd-root) do_create_initrd_root $@ ;;
    build-initrd) do_build_initrd $1 ;;
    kernel-run) do_kernel_run $@ ;;
    kernel-quit) do_kernel_quit ;;
    kernel-install) do_kernel_install $@ ;;
    kernel-boot) do_kernel_boot_select $@ ;;
    auto-apply) do_auto_apply $@ ;;
    auto-bisect) do_auto_bisect $@ ;;
    send-patch) do_send_patch $@ ;;
    ssh-host) do_ssh_host $@ ;;
    git-commit-set-cc) do_git_commit_set_cc $@ ;;
    git-commit-get-cc) do_git_commit_get_cc $@ ;;
    git-self-review) do_git_self_review $@ ;;
    git-fix-commit) do_git_commit_fix $@ ;;
    git-compile-check) do_git_compile_check $@ ;;
    git-tag-cleanup) do_git_tag_cleanup $@ ;;
    fake-editor) do_fake_editor $@ ;;
    prepare-send) do_prepare_send $@ ;;
    pci) go_python $cmd $@ ;;
    vpnc-dial-in) do_vpnc_dial_in $@ ;;
    kernel-backtrace) do_backtrace $@ ;;
    kernel-cleanup) do_kernel_cleanup $@ ;;
    kernel-grep-function) do_kernel_grep_function $@ ;;
    status-report) go_python $cmd $@ ;;
    *) usage ;;
esac

exit $?
