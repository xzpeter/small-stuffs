#!/bin/bash

prog_name=$0

usage ()
{
    cat <<EOF
usage: $prog_name <cmd>

supportted cmds:

qemu-build:    build QEMU repository.
init-dev:      init dev environment for host
build-initrd:  build initrd.img from directory
kernel-run:    run specific kernel using QEMU
kernel-quit:   stop the running kernel...
auto-apply:    apply patche list automatically

EOF
    exit 1
}

err ()
{
    echo "ERROR: $@"
    exit 1
}

do_qemu_build ()
{
    local current=$(pwd)
    local pdir=$(dirname $current)
    local top=$(basename $current)

    if [[ "$top" != "bin" ]]; then
        echo "please run this under QEMU_ROOT/bin"
        return 1
    fi

    ../configure --target-list=x86_64-softmmu --enable-debug \
                 --enable-spice --enable-usb-redir

    if [[ $? != 0 ]]; then
        echo "configure failed, stop here"
        return 1
    fi

    make -j8
    if [[ $? != 0 ]]; then
        echo "build failed... stop here"
        return 1
    fi
}

do_init_dev ()
{
    local files=".inputrc .bashrc .gitconfig .vimrc"
    local host="$1"

    if [[ -z "$host" ]]; then
        cat <<EOF
usage: $prog_name init-dev <host>

Init dev environment for <host>. <host> is required.
EOF
        return 1
    fi

    echo "copy SSH public key..."
    ssh-copy-id $host || err "failed copy SSH public key"

    echo "copy config files..."
    for file in $files; do
        path=/root/$file
        scp $path $host:$path || err "copy file $path failed"
    done
}

initrd_img="initrd.img"

do_build_initrd ()
{
    local dir="$1"
    local err=0
    if [[ -z "$dir" ]]; then
        cat <<EOF
usage: $prog_name build-initrd <dir>

Build $initrd_img file by packing dir.
EOF
        exit 1
    fi

    # check /init script
    if [[ ! -f "$dir/init" ]]; then
        echo "please provide $dir/init file (at least!)"
        return 1
    fi

    local img="$PWD/$initrd_img"
    pushd $dir &> /dev/null
    find . | cpio -H newc -o | gzip > $img
    if [[ $? == 0 ]]; then
        echo "$initrd_img created at $img"
        err=0
    else
        echo "failed to create $initrd_img"
        err=1
    fi
    popd &> /dev/null
    return $err
}

# before run this, we should have the following directories under PWD:
# "kernel": as INSTALL_PATH for kernel make
# "initramfs": rootfs for the system to be booted
# "modules": as INSTALL_MOD_PATH for kernel make (currently not used)
do_kernel_run()
{
    kernel_dir="$PWD/kernel"
    initrd_dir="$PWD/initramfs"
    qemu_bin=$(which qemu-kvm 2>/dev/null)

    if [[ $? != 0 ]]; then
        echo "please install qemu-kvm first"
        return 1
    fi

    if [[ ! -d "$kernel_dir" ]]; then
        echo "cannot find kernel dir $kernel_dir"
        return 1
    fi

    if [[ ! -d "$initrd_dir" ]]; then
        echo "cannot find initramfs dir $initrd_dir"
        return 1
    fi

    # build initrd every time!
    if ! do_build_initrd $initrd_dir; then
        return 1
    fi

    # try to find the kernel
    kernel_file=$(find $kernel_dir -name "vmlinuz*")
    lines=$(echo "$kernel_file" | wc -l)

    if [[ "$lines" != 1 ]]; then
        echo "found more than one kernel under $kernel_dir?"
        return 1
    fi

    $qemu_bin -enable-kvm -m 1024 -kernel $kernel_file \
              -initrd $initrd_img -nographic \
              -append "console=ttyS0" -s -S

    # after this, we should be able to debug the kernel using:
    # $ gdb $VMLINUX_PATH
    # (gdb) set architecture i386:x86-64:intel
    # (gdb) target remote localhost:1234
}

do_kernel_quit ()
{
    pkill -f "$prog_name kernel-run"
}

do_auto_apply()
{
    patches="$@"
    count=0
    if [[ -z "$patches" ]]; then
        echo "usage: auto_apply <patch1> [patch2 [patch3 ...]]"
        echo
        echo "This will do the following:"
        echo "  1. Try apply patch locally (try -p0 then -p1)"
        echo "  2. Commit the patch using git"
        echo
        echo "Will stop when failed to apply a patch"
        echo
        echo "Example: # qtool auto_apply /root/rpmbuild/SOURCES/*.patch"
        return 1
    fi
    for patch in $patches; do
        applied=false
        if [[ $patch != /* ]]; then
            echo "Please provide patch full path for $patch"
            return 1
        fi
        for level in 1 0; do
            patch -t -p$level < $patch
            if [[ $? == 0 ]]; then
                applied=true
                break
            fi
        done
        if ! $applied; then
            echo "patch '$patch' failed to apply, stop here."
            return 1
        fi
        # TODO: when there are new files, I'd better detect it and
        # commit too.
        git commit -a -m "Apply patch $(basename $patch)"
        count=$(( $count + 1 ))
    done
    echo "All $count patches applied successfully."
    echo "Please service yourself to cleanup *.orig."
}

cmd=$1
shift 1

case $cmd in
    qemu-build) do_qemu_build ;;
    init-dev) do_init_dev $1 ;;
    build-initrd) do_build_initrd $1 ;;
    kernel-run) do_kernel_run ;;
    kernel-quit) do_kernel_quit ;;
    auto-apply) do_auto_apply $@ ;;
    *)
        usage ;;
esac

exit $?
