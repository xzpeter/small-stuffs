#!/bin/bash

prog_name=$0

usage ()
{
    cat <<EOF
usage: $prog_name <cmd>

supportted cmds:

qemu-build:            build QEMU repository.
init-dev:              init dev environment for host
create-initrd-root:    create basic initramfs under directory specified
build-initrd:          build initrd.img from directory
kernel-run:            run specific kernel using QEMU
kernel-quit:           stop the running kernel...
kernel-install:        install the kernel (to specific VM)
kernel-boot:           choose which version of kernel to boot in host
auto-apply:            apply patche list automatically
auto-bisect:           automatic bisection of bad codes

EOF
    exit 1
}

err ()
{
    echo "ERROR: $@"
    exit 1
}

do_qemu_build ()
{
    local current=$(pwd)
    local pdir=$(dirname $current)
    local top=$(basename $current)
    local args="$@"

    if [[ "$args" == "--help" ]]; then
        cat <<EOF
usage: $prog_name qemu-build [extra-config-params]

Configure/Build QEMU under $QEMU_REPO/bin/ directory.
EOF
        return 1
    fi

    if [[ "$top" != "bin" ]]; then
        echo "please run this under QEMU_ROOT/bin"
        return 1
    fi

    ../configure --target-list=x86_64-softmmu --enable-debug \
                 --enable-spice --enable-usb-redir $@

    if [[ $? != 0 ]]; then
        echo "configure failed, stop here"
        return 1
    fi

    make -j8
    if [[ $? != 0 ]]; then
        echo "build failed... stop here"
        return 1
    fi
}

do_init_dev ()
{
    local files=".inputrc .bashrc .gitconfig .vimrc"
    local host="$1"

    if [[ -z "$host" ]]; then
        cat <<EOF
usage: $prog_name init-dev <host>

Init dev environment for <host>. <host> is required.
EOF
        return 1
    fi

    echo "copy SSH public key..."
    ssh-copy-id $host || err "failed copy SSH public key"

    echo "copy config files..."
    for file in $files; do
        path=/root/$file
        scp $path $host:$path || err "copy file $path failed"
    done
}

initrd_img="initrd.img"

do_build_initrd ()
{
    local dir="$1"
    local err=0
    if [[ -z "$dir" ]]; then
        cat <<EOF
usage: $prog_name build-initrd <dir>

Build $initrd_img file by packing dir.
EOF
        exit 1
    fi

    # check /init script
    if [[ ! -f "$dir/init" ]]; then
        echo "please provide $dir/init file (at least!)"
        return 1
    fi

    local img="$PWD/$initrd_img"
    pushd $dir &> /dev/null
    find . | cpio -H newc -o | gzip > $img
    if [[ $? == 0 ]]; then
        echo "$initrd_img created at $img"
        err=0
    else
        echo "failed to create $initrd_img"
        err=1
    fi
    popd &> /dev/null
    return $err
}

# before run this, we should have the following directories under PWD:
# "kernel": as INSTALL_PATH for kernel make
# "initramfs": rootfs for the system to be booted. to create one,
#              check: http://jootamam.net/howto-initramfs-image.htm
# "modules": as INSTALL_MOD_PATH for kernel make (currently not used)
do_kernel_run()
{
    # specify "-S" to halt QEMU when boot
    extra_params="$@"
    kernel_dir="$PWD/kernel"
    initrd_dir="$PWD/initramfs"
    qemu_bin=$(which qemu-kvm 2>/dev/null)

    if [[ $? != 0 ]]; then
        echo "please install qemu-kvm first"
        return 1
    fi

    if [[ ! -d "$kernel_dir" ]]; then
        echo "cannot find kernel dir $kernel_dir"
        return 1
    fi

    if [[ ! -d "$initrd_dir" ]]; then
        echo "cannot find initramfs dir $initrd_dir"
        return 1
    fi

    # build initrd every time!
    if ! do_build_initrd $initrd_dir; then
        return 1
    fi

    # try to find the kernel
    kernel_file=$(find $kernel_dir -name "vmlinuz*")
    lines=$(echo "$kernel_file" | wc -l)

    if [[ "$lines" != 1 ]]; then
        echo "found more than one kernel under $kernel_dir?"
        return 1
    fi

    $qemu_bin -enable-kvm -m 1024 -kernel $kernel_file \
              -initrd $initrd_img -nographic \
              -append "console=ttyS0" -s $extra_params

    # after this, we should be able to debug the kernel using:
    # $ gdb $VMLINUX_PATH
    # (gdb) set architecture i386:x86-64:intel
    # (gdb) target remote localhost:1234
}

do_kernel_quit ()
{
    pkill -f "$prog_name kernel-run"
}

do_auto_apply()
{
    patches="$@"
    count=0
    if [[ -z "$patches" ]]; then
        echo "usage: auto_apply <patch1> [patch2 [patch3 ...]]"
        echo
        echo "This will do the following:"
        echo "  1. Try apply patch locally (try -p0 then -p1)"
        echo "  2. Commit the patch using git"
        echo
        echo "Will stop when failed to apply a patch"
        echo
        echo "Example: # qtool auto_apply /root/rpmbuild/SOURCES/*.patch"
        return 1
    fi
    for patch in $patches; do
        applied=false
        if [[ $patch != /* ]]; then
            echo "Please provide patch full path for $patch"
            return 1
        fi
        for level in 1 0; do
            patch -t -p$level < $patch
            if [[ $? == 0 ]]; then
                applied=true
                break
            fi
        done
        if ! $applied; then
            echo "patch '$patch' failed to apply, stop here."
            return 1
        fi
        # TODO: when there are new files, I'd better detect it and
        # commit too.
        git commit -a -m "Apply patch $(basename $patch)"
        count=$(( $count + 1 ))
    done
    echo "All $count patches applied successfully."
    echo "Please service yourself to cleanup *.orig."
}

init_script_def='#!/bin/sh

# Based on: http://jootamam.net/howto-initramfs-image.htm

# Create all the symlinks to /bin/busybox
/bin/busybox --install -s /bin

# Mount things needed by this script
mount -t proc proc /proc
mount -t sysfs sysfs /sys

# Disable kernel messages from popping onto the screen
# echo 0 > /proc/sys/kernel/printk

# Create device nodes
mknod /dev/null c 1 3
mknod /dev/tty c 5 0
mdev -s

# Function for parsing command line options with "=" in them
# get_opt("init=/sbin/init") will return "/sbin/init"
get_opt() {
        echo "$@" | cut -d "=" -f 2
}

# Defaults
init="/sbin/init"
root="/dev/vda1"

# Process command line options
for i in $(cat /proc/cmdline); do
        case $i in
                root\=*)
                        root=$(get_opt $i)
                        ;;
                init\=*)
                        init=$(get_opt $i)
                        ;;
        esac
done

# Mount the root device
mount "${root}" /newroot

# Check if $init exists and is executable
if [[ -x "/newroot/${init}" ]] ; then
        # Unmount all other mounts so that the ram used by
        # the initramfs can be cleared after switch_root
        umount /sys /proc

        #Switch to the new root and execute init
        exec switch_root /newroot "${init}"
fi

# This will only be run if the exec above failed
echo "Failed to switch_root, dropping to a shell"
exec sh
'

do_create_initrd_root ()
{
    local dir_name="$1"

    if [[ -z "$dir_name" ]]; then
        cat <<EOF
usage: $prog_name create-initrd-root <dir_name>

This command will create one minimum rootfs layout under <dir_name>
specified.
EOF
        return 1
    fi

    if [[ -e "$dir_name" ]]; then
        echo -n "Path $dir_name exists, "
        echo "please manually remove it before hand"
        return 1
    fi

    local busybox_path=$(which busybox 2>&1)
    if [[ $? != 0 ]]; then
        echo "Failed to find busybox, please install it before hand"
        return 1
    fi

    mkdir $dir_name || err "create dir $dir_name failed"

    cd $dir_name
    local dir_list="bin sbin etc proc sys newroot"
    local name=""

    echo "Creating directories: $dir_list"
    for name in $dir_list; do
        mkdir $name
    done

    echo "Creating mdev.conf"
    touch etc/mdev.conf

    echo "Installing busybox"
    cp $busybox_path bin/busybox
    chmod a+x bin/busybox
    ln -s busybox bin/sh

    echo "Creating /init"
    echo "$init_script_def" > init
    chmod a+x init

    echo "Initramfs root created under $dir_name successfully."
    return 0
}

__host_ssh_reachable ()
{
    ssh $1 ls &> /dev/null
}

do_kernel_install ()
{
    # set this if we want to copy the kernels to VM
    local vm="$1"
    local set_default="$3"
    local output_dir="qtool_output"

    if [[ -z "$vm" ]]; then
        cat <<EOF
usage: $prog_name kernel-install <vm> [set_default]

This will install kernel and modules into <vm>.

<vm>: should be the name of the VM, with SSH pub key copied before
      hand.

[set_default]: set this parameter non-empty to set new kernel as
               default one
EOF
        return 1
    fi

    if ! __host_ssh_reachable $vm; then
        echo "VM $vm not reachable by SSH"
        return 1
    fi

    rm -rf $output_dir
    mkdir $output_dir
    echo "Preparing kernel..."
    make install INSTALL_PATH=$output_dir
    echo "Preparing modules..."
    make modules_install INSTALL_MOD_PATH=$output_dir

    # get kernel version
    local kernel_version=""
    kernel_version=$(ls $output_dir/vmlinuz-*)
    if [[ $? != 0 ]]; then
        echo "failed to find file $output_dir/vmlinuz-*"
        return 1
    fi
    kernel_version=${kernel_version##*vmlinuz-}
    echo "Kernel version to install:  '$kernel_version'"
    echo "Remote machine hostname:    '$vm'"

    # cleanup "build" and "source" in case they are soft links
    local module_dir="$output_dir/lib/modules/${kernel_version}"
    if [[ ! -d $module_dir ]]; then
        echo "failed to find module directory: $module_dir"
        return 1
    fi
    for file in build source; do
        rm -f $module_dir/$file
    done

    echo "removing old kernels and modules (if exists)"
    # kernel and system map
    ssh $vm rm -f /boot/*${kernel_version}
    # the initramfs
    ssh $vm rm -f /boot/*${kernel_version}.img
    ssh $vm rm -rf /lib/modules/${kernel_version}

    echo "installing modules"
    scp -r $module_dir $vm:/lib/modules > /dev/null

    echo "installing kernel"
    scp $output_dir/*-${kernel_version} $vm:/boot/ > /dev/null

    echo "generating initramfs"
    ssh $vm dracut -H --kver $kernel_version

    echo "updating grub2"
    ssh $vm grub2-mkconfig -o /boot/grub2/grub.cfg

    if [[ -n "$set_default" ]]; then
        echo "setting default boot kernel to $kernel_version"
        qtool kernel-boot $vm $kernel_version
    fi

    echo "all done"
}

do_kernel_boot_select ()
{
    local vm="$1"
    local version="$2"

    if [[ -z "$vm" || -z "$version" ]]; then
        cat <<EOF
usage: $prog_name kernel-boot <host> <kernel_version>

Modify grub configuration to boot into <kernel_version> next time. 
EOF
        return 1
    fi

    if ! __host_ssh_reachable $vm; then
        echo "host $vm not reachable"
        return 1
    fi

    local index=""
    index=$(ssh $vm grub2-mkconfig -o /boot/grub2/grub.cfg 2>&1 | \
                sed -n '/linux image/p' | sed -n /${version}\$/=)
    if [[ -z "$index" ]]; then
        echo "failed to find kernel version $version on host $vm"
        return 1
    fi
    # move start offset to 0 (not 1)
    index=$(( $index - 1 ))
    ssh $vm sed -i "s\/^GRUB_DEFAULT=.*\$\/GRUB_DEFAULT=${index}\/" \
        /etc/default/grub
    ssh $vm grub2-mkconfig -o /boot/grub2/grub.cfg &> /dev/null
}

qtool_def_bisect_script=".qtool.bisect"

__auto_bisect_help()
{
    cat <<EOF
usage:

# $prog_name auto-bisect generate

  Generate the default bisect file $qtool_def_bisect_script

# $prog_name auto-bisect run

  Run the bisect script $qtool_def_bisect_script

The script file should contain the following functions:

qtool_bisect_prepare:    build codes into binaries, and install
qtool_bisect_run:        run scripts to trigger the bug, return 0
                         means test pass, ~0 means test fail

The logic of bisection will be:

1. qtool_bisect_prepare
2. qtool_bisect_run --> result
3. update result to git
4. finished ? (END) : (goto 1.)
EOF
    return 1
}

__auto_bisect_generate_script ()
{
    if [[ -e $1 ]]; then
        echo "found existing script at $1, please remove before new"
        return 1
    fi
    cat > $1 <<EOF
#!/bin/bash

qtool_bisect_prepare ()
{
    echo "Preparing for run..."

    # do everything needed for the new run, should include but not
    # limited to: build, install, config, etc.

    # return 0 on success, 1 on error
    return 0
}

qtool_bisect_run ()
{
    echo "Running bisect script..."

    # run script to see whether test pass

    # return 0 on test pass, 1 on fail, 2 on error
    return 0
}
EOF
}

__auto_bisect_run()
{
    local round=1
    local result=0
    source $1

    while true; do
        echo "###############################"
        echo "# Round $round of prepare"
        echo "###############################"
        date
        if ! qtool_bisect_prepare; then
            echo "failed prepare bisect"
            return 1
        fi

        echo "###############################"
        echo "# Round $round of run"
        echo "###############################"
        date
        qtool_bisect_run
        result=$?

        case $result in
            1) git_answer=bad ;;
            0) git_answer=good ;;
            *)
                echo "error happened during running bisect script"
                return 1
                ;;
        esac

        echo "#######################################"
        echo "# Round $round of git update: $git_answer"
        echo "#######################################"
        git bisect $git_answer | grep -q "first bad"
        if [[ $? == 0 ]]; then
            # we got the bad one
            echo "found bad commit, stop here"
            git bisect log | tail -1
            break
        fi

        round=$(( $round + 1 ))
    done

    return 0
}

do_auto_bisect ()
{
    local cmd="$1"
    local script="$qtool_def_bisect_script"

    if [[ -z "$cmd" ]]; then
        __auto_bisect_help
        return 1
    fi

    case $cmd in
        generate) __auto_bisect_generate_script $script ;;
        run) __auto_bisect_run $script ;;
        *) __auto_bisect_help ;;
    esac

    return $?
}

cmd=$1
shift 1

case $cmd in
    qemu-build) do_qemu_build $@ ;;
    init-dev) do_init_dev $1 ;;
    create-initrd-root) do_create_initrd_root $@ ;;
    build-initrd) do_build_initrd $1 ;;
    kernel-run) do_kernel_run $@ ;;
    kernel-quit) do_kernel_quit ;;
    kernel-install) do_kernel_install $@ ;;
    kernel-boot) do_kernel_boot_select $@ ;;
    auto-apply) do_auto_apply $@ ;;
    auto-bisect) do_auto_bisect $@ ;;
    *) usage ;;
esac

exit $?
