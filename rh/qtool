#!/bin/bash

prog_name=$0
my_email="peterx@redhat.com"
my_fullname="Peter Xu"
my_sob_line="Signed-off-by: ${my_fullname} <${my_email}>"
debug=false

# we count the user of the fake editor, when reach zero, we unset
# the fake editor. To gain ref, use git_set_fake_editor(), to
# release ref, use git_unset_fake_editor()
fake_editor_refcount=0

usage ()
{
    cat <<EOF
usage: $prog_name <cmd>

supportted cmds:

auto-apply:            apply patche list automatically
auto-bisect:           automatic bisection of bad codes
build-initrd:          build initrd.img from directory
create-initrd-root:    create basic initramfs under directory specified
fake-editor:           this is a fake editor, it pauses, wait for a
                       SIGUSR1 and then quit with errno=0
git-commit-set-cc:     auto-generate CC list for commit
                       (this will remove all existing CC list!)
git-commit-get-cc:     list all CC list for specific commit
fix-commit:            fix specific commit (rebase)
init-dev:              init dev environment for host
kernel-boot:           choose which version of kernel to boot in host
kernel-install:        install the kernel (to specific VM)
kernel-quit:           stop the running kernel...
kernel-run:            run specific kernel using QEMU
prepare-send:          prepare one script to send patches
qemu-build:            build QEMU repository.
send-patch:            send patches using git-send-email
ssh-host:              SSH to host, with line buffering

EOF
    exit 1
}

debug ()
{
    if $debug; then
        echo -n "[DEBUG_QTOOL] " >&2
        echo $@ >&2
    fi
}

err ()
{
    echo "ERROR: $@"
    exit 1
}

wait_until_file_exists ()
{
    while [[ ! -f "$1" ]]; do
        sleep 0.1
    done
}

wait_pid_quit ()
{
    while kill -0 $1 &> /dev/null; do
        sleep 0.1
    done
}

do_qemu_build ()
{
    local current=$(pwd)
    local pdir=$(dirname $current)
    local top=$(basename $current)
    local args="$@"

    if [[ "$args" == "--help" ]]; then
        cat <<EOF
usage: $prog_name qemu-build [extra-config-params]

Configure/Build QEMU under $QEMU_REPO/bin/ directory.
EOF
        return 1
    fi

    if [[ ! "$top" == bin* ]]; then
        echo "please run this under QEMU_ROOT/bin*"
        return 1
    fi

    ../configure --target-list=x86_64-softmmu,aarch64-softmmu \
                 --enable-debug --enable-spice \
                 --enable-usb-redir $@

    if [[ $? != 0 ]]; then
        echo "configure failed, stop here"
        return 1
    fi

    make -j8
    if [[ $? != 0 ]]; then
        echo "build failed... stop here"
        return 1
    fi
}

do_init_dev ()
{
    local files=".inputrc .bashrc .gitconfig .vimrc"
    local host="$1"

    if [[ -z "$host" ]]; then
        cat <<EOF
usage: $prog_name init-dev <host>

Init dev environment for <host>. <host> is required.
EOF
        return 1
    fi

    echo "copy SSH public key..."
    ssh-copy-id $host || err "failed copy SSH public key"

    echo "copy config files..."
    for file in $files; do
        path=/root/$file
        scp $path $host:$path || err "copy file $path failed"
    done
}

initrd_img="initrd.img"

do_build_initrd ()
{
    local dir="$1"
    local err=0
    if [[ -z "$dir" ]]; then
        cat <<EOF
usage: $prog_name build-initrd <dir>

Build $initrd_img file by packing dir.
EOF
        exit 1
    fi

    # check /init script
    if [[ ! -f "$dir/init" ]]; then
        echo "please provide $dir/init file (at least!)"
        return 1
    fi

    local img="$PWD/$initrd_img"
    pushd $dir &> /dev/null
    find . | cpio -H newc -o | gzip > $img
    if [[ $? == 0 ]]; then
        echo "$initrd_img created at $img"
        err=0
    else
        echo "failed to create $initrd_img"
        err=1
    fi
    popd &> /dev/null
    return $err
}

# before run this, we should have the following directories under PWD:
# "kernel": as INSTALL_PATH for kernel make
# "initramfs": rootfs for the system to be booted. to create one,
#              check: http://jootamam.net/howto-initramfs-image.htm
# "modules": as INSTALL_MOD_PATH for kernel make (currently not used)
do_kernel_run()
{
    # specify "-S" to halt QEMU when boot
    extra_params="$@"
    kernel_dir="$PWD/kernel"
    initrd_dir="$PWD/initramfs"
    qemu_bin=$(which qemu-kvm 2>/dev/null)

    if [[ $? != 0 ]]; then
        echo "please install qemu-kvm first"
        return 1
    fi

    if [[ ! -d "$kernel_dir" ]]; then
        echo "cannot find kernel dir $kernel_dir"
        return 1
    fi

    if [[ ! -d "$initrd_dir" ]]; then
        echo "cannot find initramfs dir $initrd_dir"
        return 1
    fi

    # build initrd every time!
    if ! do_build_initrd $initrd_dir; then
        return 1
    fi

    # try to find the kernel
    kernel_file=$(find $kernel_dir -name "vmlinuz*")
    lines=$(echo "$kernel_file" | wc -l)

    if [[ "$lines" != 1 ]]; then
        echo "found more than one kernel under $kernel_dir?"
        return 1
    fi

    $qemu_bin -enable-kvm -m 1024 -kernel $kernel_file \
              -initrd $initrd_img -nographic \
              -append "console=ttyS0" -s $extra_params

    # after this, we should be able to debug the kernel using:
    # $ gdb $VMLINUX_PATH
    # (gdb) set architecture i386:x86-64:intel
    # (gdb) target remote localhost:1234
}

do_kernel_quit ()
{
    pkill -f "$prog_name kernel-run"
}

do_auto_apply()
{
    patches="$@"
    count=0
    if [[ -z "$patches" ]]; then
        echo "usage: auto_apply <patch1> [patch2 [patch3 ...]]"
        echo
        echo "This will do the following:"
        echo "  1. Try apply patch locally (try -p0 then -p1)"
        echo "  2. Commit the patch using git"
        echo
        echo "Will stop when failed to apply a patch"
        echo
        echo "Example: # qtool auto_apply /root/rpmbuild/SOURCES/*.patch"
        return 1
    fi
    for patch in $patches; do
        applied=false
        if [[ $patch != /* ]]; then
            echo "Please provide patch full path for $patch"
            return 1
        fi
        for level in 1 0; do
            patch -t -p$level < $patch
            if [[ $? == 0 ]]; then
                applied=true
                break
            fi
        done
        if ! $applied; then
            echo "patch '$patch' failed to apply, stop here."
            return 1
        fi
        # TODO: when there are new files, I'd better detect it and
        # commit too.
        git commit -a -m "Apply patch $(basename $patch)"
        count=$(( $count + 1 ))
    done
    echo "All $count patches applied successfully."
    echo "Please service yourself to cleanup *.orig."
}

init_script_def='#!/bin/sh

# Based on: http://jootamam.net/howto-initramfs-image.htm

# Create all the symlinks to /bin/busybox
/bin/busybox --install -s /bin

# Mount things needed by this script
mount -t proc proc /proc
mount -t sysfs sysfs /sys

# Disable kernel messages from popping onto the screen
# echo 0 > /proc/sys/kernel/printk

# Create device nodes
mknod /dev/null c 1 3
mknod /dev/tty c 5 0
mdev -s

# Function for parsing command line options with "=" in them
# get_opt("init=/sbin/init") will return "/sbin/init"
get_opt() {
        echo "$@" | cut -d "=" -f 2
}

# Defaults
init="/sbin/init"
root="/dev/vda1"

# Process command line options
for i in $(cat /proc/cmdline); do
        case $i in
                root\=*)
                        root=$(get_opt $i)
                        ;;
                init\=*)
                        init=$(get_opt $i)
                        ;;
        esac
done

# Mount the root device
mount "${root}" /newroot

# Check if $init exists and is executable
if [[ -x "/newroot/${init}" ]] ; then
        # Unmount all other mounts so that the ram used by
        # the initramfs can be cleared after switch_root
        umount /sys /proc

        #Switch to the new root and execute init
        exec switch_root /newroot "${init}"
fi

# This will only be run if the exec above failed
echo "Failed to switch_root, dropping to a shell"
exec sh
'

do_create_initrd_root ()
{
    local dir_name="$1"

    if [[ -z "$dir_name" ]]; then
        cat <<EOF
usage: $prog_name create-initrd-root <dir_name>

This command will create one minimum rootfs layout under <dir_name>
specified.
EOF
        return 1
    fi

    if [[ -e "$dir_name" ]]; then
        echo -n "Path $dir_name exists, "
        echo "please manually remove it before hand"
        return 1
    fi

    local busybox_path=$(which busybox 2>&1)
    if [[ $? != 0 ]]; then
        echo "Failed to find busybox, please install it before hand"
        return 1
    fi

    mkdir $dir_name || err "create dir $dir_name failed"

    cd $dir_name
    local dir_list="bin sbin etc proc sys newroot"
    local name=""

    echo "Creating directories: $dir_list"
    for name in $dir_list; do
        mkdir $name
    done

    echo "Creating mdev.conf"
    touch etc/mdev.conf

    echo "Installing busybox"
    cp $busybox_path bin/busybox
    chmod a+x bin/busybox
    ln -s busybox bin/sh

    echo "Creating /init"
    echo "$init_script_def" > init
    chmod a+x init

    echo "Initramfs root created under $dir_name successfully."
    return 0
}

__host_ssh_reachable ()
{
    ssh $1 ls &> /dev/null
}

do_kernel_install ()
{
    # set this if we want to copy the kernels to VM
    local vm="$1"
    shift 1
    local params="$@"
    local set_default=false
    local kernel_only=false
    local output_dir="qtool_output"

    if [[ -z "$vm" ]]; then
        cat <<EOF
usage: $prog_name kernel-install <vm> [option [option...]]

This will install kernel and modules into <vm>.

<vm>: should be the name of the VM, with SSH pub key copied before
      hand.

Supported options:

set_default: set this parameter non-empty to set new kernel as
             default one
kernel_only: only install compressed kernel to /boot

EOF
        return 1
    fi

    if ! __host_ssh_reachable $vm; then
        echo "VM $vm not reachable by SSH"
        return 1
    fi

    local param=""
    for param in $params; do
        case $param in
            set_default) set_default=true ;;
            kernel_only) kernel_only=true ;;
            *) echo "unknown option: $param"; return 1 ;;
        esac
    done

    rm -rf $output_dir
    mkdir $output_dir

    ##############################
    # kernel
    ##############################

    echo "Preparing kernel..."
    make install INSTALL_PATH=$output_dir

    # get kernel version
    local kernel_version=""
    kernel_version=$(ls $output_dir/vmlinuz-*)
    if [[ $? != 0 ]]; then
        echo "failed to find file $output_dir/vmlinuz-*"
        return 1
    fi
    kernel_version=${kernel_version##*vmlinuz-}
    echo "Kernel version to install:  '$kernel_version'"
    echo "Remote machine hostname:    '$vm'"

    echo "removing old kernel (if exists)"
    ssh $vm rm -f /boot/*${kernel_version}

    echo "installing kernel"
    scp $output_dir/*-${kernel_version} $vm:/boot/ > /dev/null

    if $kernel_only; then
        echo "doing kernel-only install, done."
        return 0
    fi

    ##############################
    # modules
    ##############################

    echo "Preparing modules..."
    make modules_install INSTALL_MOD_PATH=$output_dir

    # cleanup "build" and "source" in case they are soft links
    local module_dir="$output_dir/lib/modules/${kernel_version}"
    if [[ ! -d $module_dir ]]; then
        echo "failed to find module directory: $module_dir"
        return 1
    fi
    for file in build source; do
        rm -f $module_dir/$file
    done

    echo "removing old modules (if exists)"
    # the initramfs
    ssh $vm rm -f /boot/*${kernel_version}.img
    ssh $vm rm -rf /lib/modules/${kernel_version}

    echo "installing modules"
    scp -r $module_dir $vm:/lib/modules > /dev/null

    echo "generating initramfs"
    ssh $vm dracut -H --kver $kernel_version

    echo "updating grub2"
    ssh $vm grub2-mkconfig -o /boot/grub2/grub.cfg

    if $set_default; then
        echo "setting default boot kernel to $kernel_version"
        qtool kernel-boot $vm $kernel_version
    fi

    echo "all done"
}

do_kernel_boot_select ()
{
    local vm="$1"
    local version="$2"

    if [[ -z "$vm" || -z "$version" ]]; then
        cat <<EOF
usage: $prog_name kernel-boot <host> <kernel_version>

Modify grub configuration to boot into <kernel_version> next time. 
EOF
        return 1
    fi

    if ! __host_ssh_reachable $vm; then
        echo "host $vm not reachable"
        return 1
    fi

    local index=""
    index=$(ssh $vm grub2-mkconfig -o /boot/grub2/grub.cfg 2>&1 | \
                sed -n '/linux image/p' | sed -n /${version}\$/=)
    if [[ -z "$index" ]]; then
        echo "failed to find kernel version $version on host $vm"
        return 1
    fi
    # move start offset to 0 (not 1)
    index=$(( $index - 1 ))
    ssh $vm sed -i "s\/^GRUB_DEFAULT=.*\$\/GRUB_DEFAULT=${index}\/" \
        /etc/default/grub
    ssh $vm grub2-mkconfig -o /boot/grub2/grub.cfg &> /dev/null
}

qtool_def_bisect_script=".qtool.bisect"

__auto_bisect_help()
{
    cat <<EOF
usage:

# $prog_name auto-bisect generate

  Generate the default bisect file $qtool_def_bisect_script

# $prog_name auto-bisect run

  Run the bisect script $qtool_def_bisect_script

The script file should contain the following functions:

qtool_bisect_prepare:    build codes into binaries, and install
qtool_bisect_run:        run scripts to trigger the bug, return 0
                         means test pass, ~0 means test fail

The logic of bisection will be:

1. qtool_bisect_prepare
2. qtool_bisect_run --> result
3. update result to git
4. finished ? (END) : (goto 1.)
EOF
    return 1
}

__auto_bisect_generate_script ()
{
    if [[ -e $1 ]]; then
        echo "found existing script at $1, please remove before new"
        return 1
    fi
    cat > $1 <<EOF
#!/bin/bash

qtool_bisect_prepare ()
{
    echo "Preparing for run..."

    # do everything needed for the new run, should include but not
    # limited to: build, install, config, etc.

    # return 0 on success, 1 on error
    return 0
}

qtool_bisect_run ()
{
    echo "Running bisect script..."

    # run script to see whether test pass

    # return 0 on test pass, 1 on fail, 2 on error
    return 0
}
EOF
}

__auto_bisect_run()
{
    local round=1
    local result=0
    source $1

    while true; do
        echo "###############################"
        echo "# Round $round of prepare"
        echo "###############################"
        date
        if ! qtool_bisect_prepare; then
            echo "failed prepare bisect"
            return 1
        fi

        echo "###############################"
        echo "# Round $round of run"
        echo "###############################"
        date
        qtool_bisect_run
        result=$?

        case $result in
            1) git_answer=bad ;;
            0) git_answer=good ;;
            *)
                echo "error happened during running bisect script"
                return 1
                ;;
        esac

        echo "#######################################"
        echo "# Round $round of git update: $git_answer"
        echo "#######################################"
        git bisect $git_answer | grep -q "first bad"
        if [[ $? == 0 ]]; then
            # we got the bad one
            echo "found bad commit, stop here"
            git bisect log | tail -1
            break
        fi

        round=$(( $round + 1 ))
    done

    return 0
}

do_auto_bisect ()
{
    local cmd="$1"
    local script="$qtool_def_bisect_script"

    if [[ -z "$cmd" ]]; then
        __auto_bisect_help
        return 1
    fi

    case $cmd in
        generate) __auto_bisect_generate_script $script ;;
        run) __auto_bisect_run $script ;;
        *) __auto_bisect_help ;;
    esac

    return $?
}

do_send_patch ()
{
    local maillist="$1"
    # always CC myself.
    local cclist="$2,$my_email"
    shift 2
    local patchlist="$@"
    local tolist=""
    local param=""

    if [[ -z "$patchlist" ]]; then
        cat <<EOF
usage: $prog_name send-patch <mailing lists> <cc list> <patch1> ...

<mailing list> and <cc list> items should be splitted by comma
(",").

Send patch list to specific mailing list, with all the people CCed
in the CC list.
EOF
        return 1
    fi

    maillist="${maillist//,/ }"
    cclist="${cclist//,/ }"

    local mlist=""
    for mlist in ${maillist}; do
        case $mlist in
            qemu*) tolist="$tolist qemu-devel@nongnu.org" ;;
            libvir*) tolist="$tolist libvir-list@redhat.com" ;;
            # this is specific email address
            *@*) tolist="$tolist $mlist" ;;
            *) echo "Unknown mailing list: $mlist"; return 1 ;;
        esac
    done

    local item=""

    if [[ -z "$tolist" ]]; then
        echo "To: cannot be empty"
        return 1
    fi

    echo "Sending To:"
    echo
    for item in $tolist; do
        echo "  $item"
        param="$param --to=$item"
    done
    echo

    echo "CC To:"
    echo
    if [[ -n "$cclist" ]]; then
        for item in $cclist; do
            echo "  $item"
            param="$param --cc=$item"
        done
    else
        echo "  (nobody)"
    fi
    echo

    echo "Patches to send:"
    echo
    for item in $patchlist; do
        echo "  $item"
        param="$param $item"
    done
    echo

    echo -n "Ready to send? (y/n) "
    read y
    if [[ $y != y ]]; then
        echo "Aborted."
        return 0
    fi

    echo "Sending..."
    git send-email $param
    echo "Done."
}

do_ssh_host()
{
    local host="$1"
    if [[ -z "$host" ]]; then
        cat <<EOF
usage: $prog_name <host>

SSH to <host> with line buffering. This might be easy to use when
ping has a very big latency from local to <host>.
EOF
        return 1
    fi

    local line=""
    cat | ssh $host
}

# this must be done before everything, since we are calling err() to
# quit when check failed
git_root_check()
{
    if [[ ! -d ".git" ]]; then
        err "Please run command under root dir of git repo"
    fi
}

git_no_modify_check ()
{
    if git status | grep -qw modified; then
        err "Detected modified files, please clean first"
    fi
}

git_config_core_editor_check ()
{
    local editor=""
    if [[ $fake_editor_refcount != 0 ]]; then
        # we are in, no need to check
        return
    fi
    editor=$(git config --local core.editor 2>/dev/null)
    if [[ -n "$editor" ]]; then
        err "Please make sure local core.editor not set"
    fi
}

git_fake_editor_check()
{
    if pgrep -fa fake-editor &> /dev/null; then
        err "Please stop all fake-editor"
    fi
}

git_commit_check()
{
    local commit="$1"
    if [[ -z "$commit" ]]; then
        err "commit empty"
    fi
    if ! git show -s --oneline $commit &> /dev/null; then
        err "commit $commit does not exist"
    fi
}

git_rebase_pre_check_all()
{
    git_root_check
    git_no_modify_check
    git_config_core_editor_check
    git_fake_editor_check
}

git_using_fake_editor()
{
    local editor=$(git config --local core.editor 2>/dev/null)
    return [[ "$editor" == *fake-editor* ]]
}

git_set_fake_editor()
{
    fake_editor_refcount=$(( $fake_editor_refcount + 1 ))
    debug "fake editor cnt: $fake_editor_refcount"

    if [[ $fake_editor_refcount == 1 ]]; then
        debug "setting fake editor"
        git config --local core.editor "$prog_name fake-editor"
    fi
}

git_unset_fake_editor()
{
    fake_editor_refcount=$(( $fake_editor_refcount - 1 ))
    debug "fake editor cnt: $fake_editor_refcount"

    if [[ $fake_editor_refcount == 0 ]]; then
        debug "unsetting fake editor"
        git config --local --unset core.editor
    fi
}

# this is the file to store which file we are editing on. Current we
# still do not support concurrent operations. However, is that
# matter? I suppose in most cases not, since we are simulating a
# human being from his typing, man!
fake_editing_file=".fake_editor.current_path"

# To play the trick, we trap USR1 signal. When script is ready to do
# anything, we can just signal this process with USR1 to quit
# gracefully.
do_fake_editor ()
{
    # save current editing file path
    echo "$1" > $fake_editing_file
    trap "keep=false" USR1
    while $keep; do
        # some other people (possibly scripts :) is editing this
        # file.. let's wait a SIGUSR1 from thay guy!
        sleep 0.05
    done
    return 0
}

fake_editor_close()
{
    # notify fake editor to quit
    pkill -f -USR1 "$prog_name fake-editor"
}

# get which file to read, also, we will make sure the file is there
# when return
fake_editor_get_path()
{
    local file=""
    # first, make sure our fake editor starts working, and it will
    # drop the path of file-to-edit here...
    wait_until_file_exists $fake_editing_file

    file=$(cat $fake_editing_file)
    debug "fake editor currently editing file: $file"
    # secondly, we need to make sure the file to be edited is
    # existing too (for git operations, git will help create them
    # with some init state, we need to wait for its ready).
    wait_until_file_exists $file

    # remove it after we used it
    rm -f $fake_editing_file

    # tell caller
    echo $file
}

do_git_commit_fix ()
{
    local commit="$1"

    if [[ -z "$commit" ]]; then
        cat <<EOF
usage: $prog_name <commit>

Fix specific commit using rebase. After fix, please use:

# git rebase --continue

To continue.
EOF
        return 1
    fi

    local git_rebase_todo=""
    local rebase_pid=""

    git_rebase_pre_check_all
    git_set_fake_editor

    # TODO: here we'd better capture PID of the fake editor
    git rebase -i "${commit}~" &> /dev/null &
    rebase_pid=$!

    git_rebase_todo=$(fake_editor_get_path)

    sed -i '1 s/pick/edit/' $git_rebase_todo

    fake_editor_close
    # we need to wait for "git rebase" finish its work, so that we
    # can have good tree status to move on
    wait_pid_quit $rebase_pid

    git_unset_fake_editor

    echo "We are on commit:"
    git show -s --oneline
    echo "Please use 'git rebase --continue' after fix done."
}

# this could be an alias of real get_maintainer script. We need to
# do the aliasing manually. The script should be able to work just
# as QEMU/Linux scripts/get_maintainer.pl.
get_maintainer_script="./.get_maintainer"

get_maintainer_script_check()
{
    if [[ ! -e "$get_maintainer_script" ]]; then
        err "failed to find script: $get_maintainer_script"
    fi
}

# split using "|"
cc_filter_list="qemu-devel@nongnu.org"

do_git_commit_get_cc ()
{
    local commit="$1"

    if [[ -z "$commit" ]]; then
        cat <<EOF
usage: $prog_name git-commit-get-cc <commit|A..B>

Get CC list for specific commit, or commit range.

List of emails to be filtered out:

$cc_filter_list
EOF
        return 1
    fi

    git_root_check
    get_maintainer_script_check

    if [[ "$commit" == *..* ]]; then
        # this is a range
        :
    else
        # this is a commit
        git_commit_check $commit
        commit="${commit}~..${commit}"
    fi

    git diff ${commit} | $get_maintainer_script | \
        sed 's/ (.*//; s/^/CC: /' | grep -vE "$cc_filter_list"
}

do_git_commit_set_cc_one ()
{
    local commit="$1"

    if [[ -z "$commit" ]]; then
        cat <<EOF
usage: $prog_name git-commit-set-cc <commit>

Will automatically add "CC:" lines for specific commit. This is
EXTREMELY DANGEROUS, please make sure you know what this is doing
before using it. To do this, rebase is required.
EOF
        return 1
    fi

    git_commit_check $commit
    git_set_fake_editor

    echo "Trying to auto-generate CC: lines for commit $commit."

    # first, switch to that commit using rebase
    do_git_commit_fix $commit > /dev/null

    # still using fake-editor, remember? ;)
    git commit --amend &> /dev/null &

    local commit_path=$(fake_editor_get_path)
    local tmp_path="./.temp_commit_msg"
    local answer=""

    echo "Original commit msg for $commit:"
    echo "================================"
    cat $commit_path | grep -v "^#" | tee $tmp_path
    echo "================================"

    # first of all, remove existing CCs
    sed -i '/^CC: /d' $tmp_path

    # then, add all maintainer CCs
    local line=""
    do_git_commit_get_cc HEAD | while read line; do
        sed -i "/${my_sob_line}/i ${line}" $tmp_path
    done

    echo "New commit msg for $commit:"
    echo "================================"
    cat $tmp_path
    echo "================================"

    echo -n "Good to go? (y/n) "
    read answer
    if [[ "$answer" == y ]]; then
        echo "Committing changes"
        cp $tmp_path $commit_path
    else
        echo "Giving up changes"
    fi
    rm -f $tmp_path

    fake_editor_close

    git rb --continue &> /dev/null

    # release fake editor refcount
    git_unset_fake_editor
}

do_git_commit_set_cc()
{
    local commit="$1"

    if [[ -z "$commit" ]]; then
        cat <<EOF
usage: $prog_name git-commit-set-cc <commit|-N|A..B>

<commit> can be one specific commit number, or something like "-3"
or "A..B" to do automatic CC appending for all the commits in the
range.
EOF
        return 1
    fi

    local line=""
    local commits=""

    commits=$(git show -s --oneline $commit | awk '{print $1}')
    for commit in $commits; do
        do_git_commit_set_cc_one $commit
    done
}

do_prepare_send ()
{
    local script=".send.sh"
    if [[ -f $script ]]; then
        echo "Script $script already exist!"
        return 1
    fi
    cat > $script <<EOF
#!/bin/bash
to_list=
cc_list=
patches=
qtool send-patch \$to_list \$cc_list \$patches
EOF
    chmod a+x $script
    echo "Script generated at $script."
}

cmd=$1
shift 1

case $cmd in
    qemu-build) do_qemu_build $@ ;;
    init-dev) do_init_dev $1 ;;
    create-initrd-root) do_create_initrd_root $@ ;;
    build-initrd) do_build_initrd $1 ;;
    kernel-run) do_kernel_run $@ ;;
    kernel-quit) do_kernel_quit ;;
    kernel-install) do_kernel_install $@ ;;
    kernel-boot) do_kernel_boot_select $@ ;;
    auto-apply) do_auto_apply $@ ;;
    auto-bisect) do_auto_bisect $@ ;;
    send-patch) do_send_patch $@ ;;
    ssh-host) do_ssh_host $@ ;;
    git-commit-set-cc) do_git_commit_set_cc $@ ;;
    git-commit-get-cc) do_git_commit_get_cc $@ ;;
    fix-commit) do_git_commit_fix $@ ;;
    fake-editor) do_fake_editor $@ ;;
    prepare-send) do_prepare_send $@ ;;
    *) usage ;;
esac

exit $?
